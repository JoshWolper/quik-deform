// guide found here: http://danostrov.com/2012/10/27/intro-to-aetemplates/
// another guide: http://www.chadvernon.com/blog/resources/maya-api-programming/attribute-editor-templates/

global proc AEQuikDeformNodeTemplate( string $nodeName )
{
    editorTemplate -beginScrollLayout;
 
	rowLayout -numberOfColumns 2
		- columnAlign2 "right" "left"
		- columnAttach2 "both" "both";
		text -label "";
		editorTemplate -callCustom "simulateButtonNew" "simulateButtonUpdate";
 
	// --------------------------------------------
	//          Simulation attributes
	// --------------------------------------------
    editorTemplate -beginLayout "Simulation Attributes" -collapse 0;

        // custom float slider for timeStep
		editorTemplate -callCustom "timeSliderAttributeNew" "timeSliderAttributeUpdate" "timeStep";
		// custom int slider for solverIterations
		editorTemplate -callCustom "iterSliderAttributeNew" "iterSliderAttributeUpdate" "solverIterations";
        editorTemplate -label "Seconds" -addControl "secondsToSimulate";
		editorTemplate -label "Framerate" -addControl "frameRate";

    editorTemplate -endLayout;

	// --------------------------------------------
	//          Object attributes
	// --------------------------------------------
	editorTemplate -beginLayout "Object Attributes" -collapse 0;
        
		editorTemplate -label "Keep Original Mesh" -addControl "keepMesh";
		// custom float slider for tetVolume
		editorTemplate -callCustom "tetVolumeAttributeNew" "tetVolumeAttributeUpdate" "tetVolume";
        // custom float slider for mass
		editorTemplate -callCustom "massSliderAttributeNew" "massSliderAttributeUpdate" "mass";
		editorTemplate -label "Initial Object Velocity" - addControl "initialVelocity";
        // custom radio buttons for volumetric vs thin-shell
		editorTemplate -callCustom "volumetricRadioAttributeNew" "volumetricRadioAttributeUpdate" "volumetric";
		 // custom float slider for youngsModulus
		editorTemplate -callCustom "youngsModulusSliderAttributeNew" "youngsModulusSliderAttributeUpdate" "youngsModulus";
		// custom float slider for poissonRatio
		editorTemplate -callCustom "poissonRatioSliderAttributeNew" "poissonRatioSliderAttributeUpdate" "poissonRatio";
		// custom textScrollList for positionConstraints
		editorTemplate -callCustom "positionConstraintTextScrollNew" "positionConstraintTextScrollUpdate";
		
	editorTemplate -endLayout;

	// --------------------------------------------
	//          External Forces attributes
	// --------------------------------------------
	editorTemplate -beginLayout "External Forces" -collapse 0;

		editorTemplate -label "Enable Gravity" -addControl "doGravity";
		editorTemplate -label "Enable Wind" -addControl "doWind";
		editorTemplate -label "Wind Direction" -addControl "windDirection";
		// custom float slider for windMagnitude
		editorTemplate -callCustom "windMagnitudeSliderAttributeNew" "windMagnitudeSliderAttributeUpdate" "windMagnitude";
		editorTemplate -label "Enable Wind Oscillation" -addControl "windOscillation";

	editorTemplate -endLayout;

	// --------------------------------------------
	//          Other attributes
	// --------------------------------------------
	// Create an "Extras" section and also add controls for any
	// attributes we have not explicitly mentioned.
    editorTemplate -addExtraControls;

    editorTemplate -endScrollLayout;

	// Tell the attribute editor not to display the attributes we don't care about.
	editorTemplate -suppress "caching";
	editorTemplate -suppress "nodeState";
	editorTemplate -suppress "frozen";
	editorTemplate -suppress "inputMesh";
	editorTemplate -suppress "outputMesh";
	editorTemplate -suppress "currentFrame";
	editorTemplate -suppress "doCompute";
	editorTemplate -suppress "positionConstraints";
}


// --------------------------------------------
//     procs to define custom UI elements
// --------------------------------------------

// ----- slider for time step -----
global proc timeSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Time Step" 
		-field true
		-minValue 0.001 
		-fieldMinValue 0.00001
		-maxValue 0.1
		-fieldMaxValue 2
		-value 0.01
		timeSlider;
	connectControl timeSlider $attrName;
}

global proc timeSliderAttributeUpdate( string $attrName )
{
   connectControl timeSlider $attrName;
}

// ----- slider for solver iterations -----
global proc iterSliderAttributeNew( string $attrName )
{
	intSliderGrp 
		-label "Solver Iterations" 
		-field true
		-minValue 1 
		-maxValue 20
		-fieldMaxValue 100 
		-value 5
		iterSlider;
	connectControl iterSlider $attrName;
}

global proc iterSliderAttributeUpdate( string $attrName )
{
   connectControl iterSlider $attrName;
}


// ----- slider for tetVolume -----
global proc tetVolumeAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Tetrahedra Max Volume" 
		-field true
		-minValue 0.1 
		-fieldMinValue 0.001
		-maxValue 10
		-fieldMaxValue 1000
		-value 1.0
		tetVolumeSlider;
	connectControl tetVolumeSlider $attrName;
}

global proc tetVolumeAttributeUpdate( string $attrName )
{
   connectControl tetVolumeSlider $attrName;
}


// ----- slider for mass -----
global proc massSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Vertex Mass" 
		-field true
		-minValue 0.01 
		-fieldMinValue 0.0001
		-maxValue 10 
		-fieldMaxValue 500
		-value 1
		massSlider;
	connectControl massSlider $attrName;
}

global proc massSliderAttributeUpdate( string $attrName )
{
   connectControl massSlider $attrName;
}


// ----- radio buttons for volumetric -----
global proc volumetricRadioAttributeNew( string $attrName)
{
	radioButtonGrp
		-label "Simulation Type"
		-numberOfRadioButtons 2
		-label1 "Volumetric"
		-data1 1
		-label2 "Thin-shell"
		-data2 0
		-select 1
		volumetricRadio;
	connectControl volumetricRadio $attrName;
}

global proc volumetricRadioAttributeUpdate( string $attrName )
{
   connectControl volumetricRadio $attrName;
}


// ----- slider for youngsModulus -----
global proc youngsModulusSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Young's Modulus" 
		-field true
		-minValue 1000
		-fieldMinValue 1
		-maxValue 10000
		-fieldMaxValue 1000000
		-value 5000
		youngsModulusSlider;
	connectControl youngsModulusSlider $attrName;
}

global proc youngsModulusSliderAttributeUpdate( string $attrName )
{
   connectControl youngsModulusSlider $attrName;
}


// ----- slider for poissonRatio -----
global proc poissonRatioSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Poisson Ratio" 
		-field true
		-minValue 0.1
		-fieldMinValue 0.01
		-maxValue 0.5
		-fieldMaxValue 1
		-value 0.3
		poissonRatioSlider;
	connectControl poissonRatioSlider $attrName;
}

global proc poissonRatioSliderAttributeUpdate( string $attrName )
{
   connectControl poissonRatioSlider $attrName;
}


// ----- slider for windMagnitude -----
global proc windMagnitudeSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Wind Magnitude" 
		-field true
		-minValue 0.1
		-fieldMinValue 0.001
		-maxValue 100
		-fieldMaxValue 1000
		-value 1
		windMagnitudeSlider;
	connectControl windMagnitudeSlider $attrName;
}

global proc windMagnitudeSliderAttributeUpdate( string $attrName )
{
   connectControl windMagnitudeSlider $attrName;
}


// ----- button for compute -----
global proc simulateButtonNew()
{
	button -label "Simulate" -command "simulateButtonCmd" simulateButton;
}

global proc simulateButtonUpdate()
{}

global proc simulateButtonCmd()
{
	string $targetNode = getSelectedQuikDeformNode();
	setAttr ($targetNode + ".doCompute") true;
}


// ----- textScrollList for positionConstraint with helper functions -----
global proc positionConstraintTextScrollNew()
{
	rowLayout 
        - numberOfColumns 2
        - columnAlign2 "right" "left"
    	- columnAttach2 "both" "both";
    	text -label "Position Constraints";
			columnLayout;
				textScrollList 
					-numberOfRows 6
					-allowMultiSelection true 
					-width 200
					-height 60
					positionConstraintTextScroll;
				rowLayout 
					-numberOfColumns 2
					-columnAlign2 "left" "left"
					-columnWidth2 80 80;
					button 
						-label "Add"
						-command "addPositionConstraintCmd" ;
					button 
						-label "Remove"
						-command "removePositionConstraintCmd" ;
				
}

global proc positionConstraintTextScrollUpdate()
{}


// add the indices currently selected
global proc addPositionConstraintCmd()
{
    // get selected items
    string $selection[] = `ls -selection`; 
    string $indices[] = extractVertexIndices($selection);
    
    // add the index if it doesn't already exist in the textScrollList
    string $allItems[] = `textScrollList -query -allItems positionConstraintTextScroll`;
    for ($index in $indices){
        if (!containsItem($allItems, $index)){
            textScrollList -edit -append $index positionConstraintTextScroll;
            textScrollList -edit -deselectAll positionConstraintTextScroll;
            textScrollList -edit -selectItem $index positionConstraintTextScroll;
        }
    }
	
	// update the underlying attributes of the node
	string $everyItem[] = `textScrollList -query -allItems positionConstraintTextScroll`;
	setPositionConstraintAttr($everyItem);
}

// delete the indices currently selected
global proc removePositionConstraintCmd()
{
    string $selected[] = `textScrollList -query -selectItem positionConstraintTextScroll`;
    for ($item in $selected){
        textScrollList -edit -removeItem $item positionConstraintTextScroll;
    }
	
	// update the underlying attributes of the node
	string $everyItem[]  = `textScrollList -query -allItems positionConstraintTextScroll`;
	setPositionConstraintAttr($everyItem);
}


// ----- helper functions used by the UI -----

// get the selected or last-created QuikDeformNode
global proc string getSelectedQuikDeformNode(){
	string $selections[] = `ls -sl`;  // get the current selection
	if (`size($selections)` > 0){
		// if selected node is a QuikDeformNode, return it right away
		string $doComputeAttr[] = `listAttr -string "doCompute" $selections[0]`;
		if (`size($doComputeAttr)` > 0){
			return $selections[0];
		}
		
		// if selected node is a face/vertex/etc., get the parent node
		string $parent = $selections[0];
		string $dot = `match ".[a-z]+\\[[0-9]+" $selections[0]`;
		if ($dot != ""){
			string $buffer[];
			tokenize $selections[0] "." $buffer;
			$parent = $buffer[0];
		}
		
		// return the QuikDeformNode related to the selected node 
		string $shapeNodes[] = `listRelatives -s $parent`;   // get the related shape node
		string $quikDeformNode[] = `listConnections -type "QuikDeformNode" $shapeNodes[0]`;   // get the connected QuikDeformNode 
		if (`size($quikDeformNode)` > 0){
			return $quikDeformNode[0];
		}
	}
	
	// else no node or no QuikDeformNode is selected, just return the latest QuikDeformNode created
	string $allNodes[] = `ls -type "QuikDeformNode"`;
	int $size = `size($allNodes)`;
	if ($size > 0){
		return $allNodes[$size - 1];
	}
	else{
		print "No valid QuikDeformNode can be found";
		return "";
	}
}


// check if a target string exists in a string array
global proc int containsItem(string $allItems[], string $target)
{
    for ($str in $allItems) {
        if ($str == $target){
            return 1;
        }
    }
    
    return 0;
}

// takes in a list of selected items, extract and return the vertex indices
global proc string[] extractVertexIndices(string $selected[])
{
    string $indices[];
    for ($item in $selected){
        // make sure this item contains vertex information
        string $vertexInfo = `match "\\.vtx\\[[0-9]*:*[0-9]*\\]$" $item`;
        if ($vertexInfo != ""){
            // check if the vertex info contains a colon
            string $colonInfo = `match "[0-9]+:[0-9]+" $vertexInfo`;
            if ($colonInfo == ""){
                // no colon, just extract and add the number from vertexInfo
                $indices[`size($indices)`] = `match "[0-9]+" $vertexInfo`;
            }
            else{
                // has colon, extract and add all numbers from vertexInfo
                string $buffer[];
                tokenize $colonInfo ":" $buffer;
                int $index1 = $buffer[0];
                int $index2 = $buffer[1];
                int $iter;
                for ($iter = $index1; $iter <= $index2; $iter++){
                    $indices[`size($indices)`] = (string)$iter;
                }
            }
        }
    }
    
    return $indices;
}


// take in a list of vertices and set the selected QuikDeformNode's attribute
global proc setPositionConstraintAttr( string $vertices[] ){
	string $vertexString;
	for ($vertex in $vertices){
		$vertexString += $vertex + ",";
	}
	print ("about to add string: " + $vertexString);
	
	string $targetNode = getSelectedQuikDeformNode();
	setAttr ($targetNode + ".positionConstraints") -type "string" $vertexString;
}