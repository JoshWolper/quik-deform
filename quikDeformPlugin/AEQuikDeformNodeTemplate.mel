// guide found here: http://danostrov.com/2012/10/27/intro-to-aetemplates/
// another guide: http://www.chadvernon.com/blog/resources/maya-api-programming/attribute-editor-templates/

global proc AEQuikDeformNodeTemplate( string $nodeName )
{
    editorTemplate -beginScrollLayout;
 
	rowLayout -numberOfColumns 2
		- columnAlign2 "right" "left"
		- columnAttach2 "both" "both";
		text -label "";
		editorTemplate -callCustom "simulateButtonNew" "simulateButtonUpdate";
 
	// --------------------------------------------
	//          Simulation attributes
	// --------------------------------------------
    editorTemplate -beginLayout "Simulation Attributes" -collapse 0;

        // custom float slider for timeStep
		editorTemplate -callCustom "timeSliderAttributeNew" "timeSliderAttributeUpdate" "timeStep";
		// custom int slider for solverIterations
		editorTemplate -callCustom "iterSliderAttributeNew" "iterSliderAttributeUpdate" "solverIterations";
        editorTemplate -label "Seconds to Simulate" -addControl "secondsToSimulate";
		editorTemplate -label "Framerate" -addControl "frameRate";

    editorTemplate -endLayout;

	// --------------------------------------------
	//          Object attributes
	// --------------------------------------------
	editorTemplate -beginLayout "Object Attributes" -collapse 0;
        
		editorTemplate -label "Keep Original Mesh" -addControl "keepMesh";
		// custom float slider for tetVolume
		editorTemplate -callCustom "tetVolumeAttributeNew" "tetVolumeAttributeUpdate" "tetVolume";
        // custom float slider for mass
		editorTemplate -callCustom "massSliderAttributeNew" "massSliderAttributeUpdate" "mass";
		editorTemplate -label "Initial Object Velocity" - addControl "initialVelocity";
        // custom radio buttons for volumetric vs thin-shell
		editorTemplate -callCustom "volumetricRadioAttributeNew" "volumetricRadioAttributeUpdate" "volumetric";
		 // custom float slider for youngsModulus
		editorTemplate -callCustom "youngsModulusSliderAttributeNew" "youngsModulusSliderAttributeUpdate" "youngsModulus";
		// custom float slider for poissonRatio
		editorTemplate -callCustom "poissonRatioSliderAttributeNew" "poissonRatioSliderAttributeUpdate" "poissonRatio";
		// custom textScrollList for positionConstraints
		editorTemplate -callCustom "positionConstraintTextScrollNew" "positionConstraintTextScrollUpdate";
		// custom button (and pop up window) for collisionConstraints
		editorTemplate -callCustom "collisionConstraintsButtonNew" "collisionConstraintsButtonUpdate";
		// custom button for frictionCoeff
		editorTemplate -callCustom "frictionCoeffSliderAttributeNew" "frictionCoeffSliderAttributeUpdate" "frictionCoeff";
		
	editorTemplate -endLayout;

	// --------------------------------------------
	//          External Forces attributes
	// --------------------------------------------
	editorTemplate -beginLayout "External Forces" -collapse 0;

		editorTemplate -label "Enable Gravity" -addControl "doGravity";
		editorTemplate -label "Enable Wind" -addControl "doWind";
		editorTemplate -label "Wind Direction" -addControl "windDirection";
		// custom float slider for windMagnitude
		editorTemplate -callCustom "windMagnitudeSliderAttributeNew" "windMagnitudeSliderAttributeUpdate" "windMagnitude";
		editorTemplate -callCustom "windAmplitudeSliderAttributeNew" "windAmplitudeSliderAttributeUpdate" "windAmplitude";
		editorTemplate -callCustom "windPeriodSliderAttributeNew" "windPeriodSliderAttributeUpdate" "windPeriod";
		editorTemplate -label "Enable Wind Oscillation" -addControl "windOscillation";

	editorTemplate -endLayout;

	// --------------------------------------------
	//          Other attributes
	// --------------------------------------------
	// Create an "Extras" section and also add controls for any
	// attributes we have not explicitly mentioned.
    editorTemplate -addExtraControls;

    editorTemplate -endScrollLayout;

	// Tell the attribute editor not to display the attributes we don't care about.
	editorTemplate -suppress "caching";
	editorTemplate -suppress "nodeState";
	editorTemplate -suppress "frozen";
	editorTemplate -suppress "inputMesh";
	editorTemplate -suppress "outputMesh";
	editorTemplate -suppress "currentFrame";
	editorTemplate -suppress "doCompute";
	editorTemplate -suppress "positionConstraints";
}


// --------------------------------------------
//     procs to define custom UI elements
// --------------------------------------------

// ----- slider for time step -----
global proc timeSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Time Step" 
		-field true
		-minValue 0.001 
		-fieldMinValue 0.00001
		-maxValue 0.1
		-fieldMaxValue 2
		-value 0.01
		timeSlider;
	connectControl timeSlider $attrName;
}

global proc timeSliderAttributeUpdate( string $attrName )
{
   connectControl timeSlider $attrName;
}

// ----- slider for solver iterations -----
global proc iterSliderAttributeNew( string $attrName )
{
	intSliderGrp 
		-label "Solver Iterations" 
		-field true
		-minValue 1 
		-maxValue 20
		-fieldMaxValue 100 
		-value 5
		iterSlider;
	connectControl iterSlider $attrName;
}

global proc iterSliderAttributeUpdate( string $attrName )
{
   connectControl iterSlider $attrName;
}


// ----- slider for tetVolume -----
global proc tetVolumeAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Tetrahedra Max Volume" 
		-field true
		-minValue 0.1 
		-fieldMinValue 0.001
		-maxValue 10
		-fieldMaxValue 1000
		-value 1.0
		tetVolumeSlider;
	connectControl tetVolumeSlider $attrName;
}

global proc tetVolumeAttributeUpdate( string $attrName )
{
   connectControl tetVolumeSlider $attrName;
}


// ----- slider for mass -----
global proc massSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Vertex Mass" 
		-field true
		-minValue 0.01 
		-fieldMinValue 0.0001
		-maxValue 10 
		-fieldMaxValue 500
		-value 1
		massSlider;
	connectControl massSlider $attrName;
}

global proc massSliderAttributeUpdate( string $attrName )
{
   connectControl massSlider $attrName;
}


// ----- radio buttons for volumetric -----
global proc volumetricRadioAttributeNew( string $attrName)
{
	radioButtonGrp
		-label "Simulation Type"
		-numberOfRadioButtons 2
		-label1 "Volumetric"
		-data1 1
		-label2 "Thin-shell"
		-data2 0
		-select 1
		volumetricRadio;
	connectControl volumetricRadio $attrName;
}

global proc volumetricRadioAttributeUpdate( string $attrName )
{
   connectControl volumetricRadio $attrName;
}


// ----- slider for youngsModulus -----
global proc youngsModulusSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Young's Modulus" 
		-field true
		-minValue 1000
		-fieldMinValue 1
		-maxValue 10000
		-fieldMaxValue 1000000
		-value 5000
		youngsModulusSlider;
	connectControl youngsModulusSlider $attrName;
}

global proc youngsModulusSliderAttributeUpdate( string $attrName )
{
   connectControl youngsModulusSlider $attrName;
}


// ----- slider for poissonRatio -----
global proc poissonRatioSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Poisson Ratio" 
		-field true
		-minValue 0.1
		-fieldMinValue 0.01
		-maxValue 0.5
		-fieldMaxValue 1
		-value 0.3
		poissonRatioSlider;
	connectControl poissonRatioSlider $attrName;
}

global proc poissonRatioSliderAttributeUpdate( string $attrName )
{
   connectControl poissonRatioSlider $attrName;
}


// ----- slider for frictionCoeff -----
global proc frictionCoeffSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Friction Coefficient" 
		-field true
		-minValue 0
		-maxValue 1
		-value 0.4
		frictionCoeffSlider;
	connectControl frictionCoeffSlider $attrName;
}

global proc frictionCoeffSliderAttributeUpdate( string $attrName )
{
   connectControl frictionCoeffSlider $attrName;
}


// ----- slider for windMagnitude -----
global proc windMagnitudeSliderAttributeNew( string $attrName )
{
		floatSliderGrp 
			-label "Wind Magnitude" 
			-field true
			-minValue 0.1
			-fieldMinValue 0.001
			-maxValue 100
			-fieldMaxValue 1000
			-value 0
			windMagnitudeSlider;
	connectControl windMagnitudeSlider $attrName;
}

global proc windMagnitudeSliderAttributeUpdate( string $attrName )
{
   connectControl windMagnitudeSlider $attrName;
}


// ----- slider for windAmplitude -----
global proc windAmplitudeSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Wind Amplitude" 
		-field true
		-minValue 0
		-maxValue 10
		-value 1
		windAmplitudeSlider;
	connectControl windAmplitudeSlider $attrName;
}

global proc windAmplitudeSliderAttributeUpdate( string $attrName )
{
   connectControl windAmplitudeSlider $attrName;
}



// ----- slider for windPeriod -----
global proc windPeriodSliderAttributeNew( string $attrName )
{
	floatSliderGrp 
		-label "Wind Period" 
		-field true
		-minValue 0.1
		-maxValue 5
		-value 0.5
		windPeriodSlider;
	connectControl windPeriodSlider $attrName;
}

global proc windPeriodSliderAttributeUpdate( string $attrName )
{
   connectControl windPeriodSlider $attrName;
}



// ----- button for compute -----
global proc simulateButtonNew()
{
	button -label "Simulate" -command "simulateButtonCmd" simulateButton;
}

global proc simulateButtonUpdate()
{}

global proc simulateButtonCmd()
{
	string $targetNode = getSelectedQuikDeformNode();
	
	// update the info for collision constraint planes
	string $constraintInfo = `getAttr ($targetNode + ".collisionConstraints")`;
	string $planes[] = getPlanesFromString($constraintInfo);
	setCollisionConstraintAttr($planes);
	
	// set doCompute to true to do computation
	setAttr ($targetNode + ".doCompute") true;
	
	print ("stuff happens here");
}


// ----- textScrollList for positionConstraint with helper functions -----
global proc positionConstraintTextScrollNew()
{
	rowLayout 
        - numberOfColumns 3
        - columnAlign3 "right" "left" "center"
    	- columnAttach3 "both" "both" "both"
		- columnWidth3 145 180 60;
    	text -label "Position Constraints";
		textScrollList 
			-numberOfRows 6
			-allowMultiSelection true 
			-height 60
			positionConstraintTextScroll;
		columnLayout -rowSpacing 5;
			button 
				-label "Add"
				-width 60
				-command "addPositionConstraintCmd" ;
			button 
				-label "Remove"
				-width 60
				-command "removePositionConstraintCmd" ;
				
}

global proc positionConstraintTextScrollUpdate()
{
    // update the textScrollList to show this node's constraints
	string $targetNode = getSelectedQuikDeformNode();
	// parse info to get vertices
	string $constraintInfo = `getAttr ($targetNode + ".positionConstraints")`;
	string $vertices[] = getVerticesFromString($constraintInfo);
	// remove all and add the current data
	textScrollList -edit -removeAll positionConstraintTextScroll;
	for ($vertex in $vertices){
		textScrollList -edit -append $vertex positionConstraintTextScroll;
	}
	textScrollList -edit -deselectAll positionConstraintTextScroll;    
}


// add the indices currently selected
global proc addPositionConstraintCmd()
{
    // get selected items
    string $selection[] = `ls -selection`; 
    string $indices[] = extractVertexIndices($selection);
    
    // add the index if it doesn't already exist in the textScrollList
    string $allItems[] = `textScrollList -query -allItems positionConstraintTextScroll`;
    for ($index in $indices){
        if (!containsItem($allItems, $index)){
            textScrollList -edit -append $index positionConstraintTextScroll;
            textScrollList -edit -deselectAll positionConstraintTextScroll;
            textScrollList -edit -selectItem $index positionConstraintTextScroll;
        }
    }
	
	// update the underlying attributes of the node
	string $everyItem[] = `textScrollList -query -allItems positionConstraintTextScroll`;
	setPositionConstraintAttr($everyItem);
}

// delete the indices currently selected
global proc removePositionConstraintCmd()
{
    string $selected[] = `textScrollList -query -selectItem positionConstraintTextScroll`;
    for ($item in $selected){
        textScrollList -edit -removeItem $item positionConstraintTextScroll;
    }
	
	// update the underlying attributes of the node
	string $everyItem[]  = `textScrollList -query -allItems positionConstraintTextScroll`;
	setPositionConstraintAttr($everyItem);
}


// ----- button for collisionConstraints -----
global proc collisionConstraintsButtonNew()
{
	rowLayout 
        - numberOfColumns 2
        - columnAlign2 "right" "left"
    	- columnAttach2 "both" "both";
		text -label "Collision Constraints";
		button -label "Customize" -width 100 -command "showCollisionConstraintsWindow" collisionConstraintButton;
}

global proc collisionConstraintsButtonUpdate()
{}

global proc showCollisionConstraintsWindow()
{
	window 
	-title "Customize Collision Constraints"
	-width 260;
		columnLayout 
			-rowSpacing 10
			-columnAlign "center" 
			-columnAttach "both" 10
			-width 260;
			text 
				-label "Showing Collision Constraints for:"
				-align "left"
				-width 260;
			text 
				-label "node1" 
				-width 260
				nodeNameText;
			textScrollList 
				-numberOfRows 6
				-allowMultiSelection true 
				-width 240
				-height 60
				-selectCommand "selectCollisionPlanes"
				collisionConstraintTextScroll;
			rowLayout 
				-numberOfColumns 2
				-columnAlign2 "left" "left"
				-columnWidth2 120 120
				-width 240;
				button 
					-label "Add"
					-width 115
					-command "addCollisionConstraintCmd" ;
				button 
					-label "Remove"
					-width 115
					-command "removeCollisionConstraintCmd" ;
				setParent ..;
			text
				-label "**please make sure only non-slanted \nplanes are selected as collision constraints**"
				-width 260;
	showWindow;
	
	// populate the window with info from the currently selected QuikDeformNode
	string $targetNode = getSelectedQuikDeformNode();
	text -edit -label $targetNode nodeNameText;
	// parse info for all collision constraints
	string $constraintInfo = `getAttr ($targetNode + ".collisionConstraints")`;
	string $names[] = getPlanesFromString($constraintInfo);
	for ($name in $names){
		textScrollList -edit -append $name collisionConstraintTextScroll;
	}
	textScrollList -edit -deselectAll collisionConstraintTextScroll;
}

// add the currently selected plane
global proc addCollisionConstraintCmd() 
{
    // get selected items
    string $selection[] = `ls -selection`; 
    
    // add the objects
    string $allItems[] = `textScrollList -query -allItems collisionConstraintTextScroll`;
    for ($object in $selection){
		print ("attempting to add " + $object);
        // make sure the object is a non-slanted plane
        float $center[] = `objectCenter -gl $object`;
        float $normal[] = getPlaneNormal($object);
        if ($normal[0] == 0 && $normal[1] == 0 && $normal[2] == 0){
            print ("Error: " + $object + " is not a non-slanted plane");
        }
        // make sure the object is not already in the textSrollList
        else if (!containsItem($allItems, $object)){
            textScrollList -edit -append $object collisionConstraintTextScroll;
        }
    }
	
	// update the underlying attributes of the node
	string $everyItem[] = `textScrollList -query -allItems collisionConstraintTextScroll`;
	setCollisionConstraintAttr($everyItem);
}

// delete the indices currently selected
global proc removeCollisionConstraintCmd()
{
    string $selected[] = `textScrollList -query -selectItem collisionConstraintTextScroll`;
    for ($item in $selected){
        textScrollList -edit -removeItem $item collisionConstraintTextScroll;
    }
	
	// update the underlying attributes of the node
	string $everyItem[] = `textScrollList -query -allItems collisionConstraintTextScroll`;
	setCollisionConstraintAttr($everyItem);
}


// --------------------------------------------
//     helper functions
// --------------------------------------------

// get the selected or last-created QuikDeformNode
global proc string getSelectedQuikDeformNode()
{
	string $selections[] = `ls -sl`;  // get the current selection
	if (`size($selections)` > 0){
		// if selected node is a QuikDeformNode, return it right away
		string $doComputeAttr[] = `listAttr -string "doCompute" $selections[0]`;
		if (`size($doComputeAttr)` > 0){
			return $selections[0];
		}
		
		// if selected node is a face/vertex/etc., get the parent node
		string $parent = $selections[0];
		string $dot = `match ".[a-z]+\\[[0-9]+" $selections[0]`;
			string $buffer[];
		if ($dot != ""){
			tokenize $selections[0] "." $buffer;
			$parent = $buffer[0];
		}
		
		// return the QuikDeformNode related to the selected node 
		string $shapeNodes[] = `listRelatives -s $parent`;   // get the related shape node
		string $quikDeformNode[] = `listConnections -type "QuikDeformNode" $shapeNodes[0]`;   // get the connected QuikDeformNode 
		if (`size($quikDeformNode)` > 0){
			return $quikDeformNode[0];
		}
	}
	
	// else no node or no QuikDeformNode is selected, just return the latest QuikDeformNode created
	string $allNodes[] = `ls -type "QuikDeformNode"`;
	int $size = `size($allNodes)`;
	if ($size > 0){
		return $allNodes[$size - 1];
	}
	else{
		print "No valid QuikDeformNode can be found";
		return "";
	}
}


// check if a target string exists in a string array
global proc int containsItem(string $allItems[], string $target)
{
    for ($str in $allItems) {
        if ($str == $target){
            return 1;
        }
    }
    
    return 0;
}

// takes in a list of selected items, extract and return the vertex indices
global proc string[] extractVertexIndices(string $selected[])
{
    string $indices[];
    for ($item in $selected){
        // make sure this item contains vertex information
        string $vertexInfo = `match "\\.vtx\\[[0-9]*:*[0-9]*\\]$" $item`;
        if ($vertexInfo != ""){
            // check if the vertex info contains a colon
            string $colonInfo = `match "[0-9]+:[0-9]+" $vertexInfo`;
            if ($colonInfo == ""){
                // no colon, just extract and add the number from vertexInfo
                $indices[`size($indices)`] = `match "[0-9]+" $vertexInfo`;
            }
            else{
                // has colon, extract and add all numbers from vertexInfo
                string $buffer[];
                tokenize $colonInfo ":" $buffer;
                int $index1 = $buffer[0];
                int $index2 = $buffer[1];
                int $iter;
                for ($iter = $index1; $iter <= $index2; $iter++){
                    $indices[`size($indices)`] = (string)$iter;
                }
            }
        }
    }
    
    return $indices;
}


// selects the selected items
global proc selectCollisionPlanes(){
    string $selected[] = `textScrollList -query -selectItem collisionConstraintTextScroll`;
    select -r $selected;
}

// returns the surface normal of the plane.
// returns 0,0,0 if plane is slanted or not a plane at all
global proc float[] getPlaneNormal( string $plane ){
    string $faces[] = `polyInfo -fn $plane`;
    float $answer[] = {0,0,0};

    for ($face in $faces) {
        string $buffer[];
        $numTokens = `tokenize $face " " $buffer`;
        
        // Get the face number
        string $strFaceNum = $buffer[1];
        $strFaceNum = substring($strFaceNum, 1, size($strFaceNum)-1);
        int $faceNum = $strFaceNum;
        
        // Get the local normal vector of each face
        float $axis[] = {(float)$buffer[2], (float)$buffer[3], (float)$buffer[4] };
        
        // Combine the local normal with the object's matrix to get it's 
        // normal in world space
        float $transform[] = `xform -q -m -ws $plane`;
        float $worldAxis[] = pointMatrixMult( $axis, $transform );
        
        // if worldAxis is close enough to 0 just make it 0
        if (equivalentTol(0, $worldAxis[0], 0.0001) == 1){
            $worldAxis[0] = 0;
        }
        if (equivalentTol(0, $worldAxis[1], 0.0001) == 1){
            $worldAxis[1] = 0;
        }
        if (equivalentTol(0, $worldAxis[2], 0.0001) == 1){
            $worldAxis[2] = 0;
        }
        
        // set the answer array if it's empty
        if ($answer[0] == 0 && $answer[1] == 0 && $answer[2] == 0)
        {
            $answer[0] = $worldAxis[0];
            $answer[1] = $worldAxis[1];
            $answer[2] = $worldAxis[2];
        }
         // make sure the world normals is non-slanted and match up with others
        if (checkValidNormal($worldAxis) == 0 ||
            $answer[0] != $worldAxis[0] ||
            $answer[1] != $worldAxis[1] ||
            $answer[2] != $worldAxis[2]) 
        {
            $answer[0] = 0;
            $answer[1] = 0;
            $answer[2] = 0;
            break;
        }
    }
    
    return $answer;
}

// check if the input normal is non-slanted
global proc int checkValidNormal( float $normal[] ){    
    if ($normal[0] != 0 && $normal[1] == 0 && $normal[2] == 0){
        return 1;
    }
    if ($normal[0] == 0 && $normal[1] != 0 && $normal[2] == 0){
        return 1;
    }
    if ($normal[0] == 0 && $normal[1] == 0 && $normal[2] != 0){
        return 1;
    }
    
    return 0;
}


// parse the given collisionConstraint string and return an array of names
global proc string[] getPlanesFromString(string $input ){
	string $planes[];
	string $names[];
	tokenize $input ";" $planes;
	for ($plane in $planes){
		// parse info for each plane
		string $info[];
		tokenize $plane "," $info;
		string $name = $info[0];
		if ($name != ""){
			$names[`size($names)`] = $name;
		}
	}
	
	return $names;
}


// parse the given positionConstraint string and return an array of vertices
global proc string[] getVerticesFromString(string $input){
    string $vertices[];
    string $result[];
    tokenize $input "," $vertices;
    for ($vertex in $vertices){
        if ($vertex != ""){
            $result[`size($result)`] = $vertex;
        }
    }
    
    return $result;
}

// take in a list of vertices and set the selected QuikDeformNode's attribute
global proc setPositionConstraintAttr( string $vertices[] ){
	string $vertexString;
	for ($vertex in $vertices){
		$vertexString += $vertex + ",";
	}
	
	print ("about to add string: " + $vertexString);
	
	string $targetNode = getSelectedQuikDeformNode();
	setAttr ($targetNode + ".positionConstraints") -type "string" $vertexString;
}


// adds the collisionConstraint info to QuikDeformNode
// planeString is a semi-colon separated string of plane info
// a plane with center at 0,0,0 and normal of 0,1,0 will be
// "plane1,0,0,0,0,1,0;"
global proc setCollisionConstraintAttr( string $planes[] ){
    string $planeString = "";
    for ($plane in $planes){
        float $center[] = `objectCenter -gl $plane`;
        float $normal[] = getPlaneNormal($plane);
        string $string = $plane + "," +
                         $center[0] + "," +
                         $center[1] + "," +
                         $center[2] + "," +
                         $normal[0] + "," +
                         $normal[1] + "," +
                         $normal[2] + ";";
        $planeString += $string;     
    }
    
    print "about to add planeString: \n";
    print $planeString;
	
	string $targetNode = getSelectedQuikDeformNode();
	setAttr ($targetNode + ".collisionConstraints") -type "string" $planeString;
}